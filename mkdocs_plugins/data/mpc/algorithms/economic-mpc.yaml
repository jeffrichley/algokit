# Enhanced Algorithm Schema for Algorithm Documentation
# This schema supports all algorithm types with rich metadata and structured content

# Basic metadata
slug: economic-mpc
name: Economic MPC
family_id: mpc

# Brief one-sentence summary for cards and navigation
summary: "Model Predictive Control that optimizes economic objectives rather than tracking performance, focusing on profit maximization and cost minimization in process industries."

# Detailed description (markdown supported) - full overview for the algorithm page
description: |
  Economic MPC extends the predictive control framework to optimize economic objectives rather than traditional tracking performance. Unlike standard MPC, which focuses on minimizing tracking errors and control effort, Economic MPC directly optimizes economic metrics such as profit, cost, energy consumption, or resource utilization.

  This approach is particularly valuable in process industries where economic performance is the primary concern. Economic MPC can handle complex economic objectives, market conditions, and operational constraints while maintaining system stability and safety. The key challenge is to balance economic optimization with system stability and constraint satisfaction.

# Problem formulation and mathematical details
formulation:
  control_law: |
    For system: x(k+1) = f(x(k), u(k), d(k)), y(k) = h(x(k), u(k))
    
    The Economic MPC formulation is:
    
    min_{U_k} J_econ(x(k), U_k) = Σ_{i=0}^{N_p-1} L_econ(x(k+i|k), u(k+i), d(k+i))
    
    Subject to:
    - x(k+i+1|k) = f(x(k+i|k), u(k+i), d(k+i))
    - y(k+i|k) = h(x(k+i|k), u(k+i))
    - g(x(k+i|k), u(k+i)) ≤ 0
    - u_min ≤ u(k+i) ≤ u_max
    - x_min ≤ x(k+i|k) ≤ x_max
    
    Where:
    - L_econ(·) is the economic stage cost function
    - Economic objectives: profit, cost, energy, resource utilization
    - Market prices and demand forecasts can be incorporated

  discrete_time_form: |
    Economic stage cost examples:
    
    1. Profit maximization:
    L_econ(x,u,d) = -[p^T y - c^T u - c_f^T x]
    
    2. Energy minimization:
    L_econ(x,u,d) = c_energy^T u
    
    3. Resource utilization:
    L_econ(x,u,d) = -w^T y (maximize output)
    
    Where:
    - p: product prices
    - c: input costs
    - c_f: inventory costs
    - c_energy: energy costs
    - w: output weights

  key_properties:
    - name: "Economic Optimization"
      formula: "min Σ L_econ(x,u,d)"
      description: "Direct optimization of economic objectives"
    - name: "Market Integration"
      formula: "L_econ = f(prices, costs, demand)"
      description: "Incorporates market conditions and forecasts"
    - name: "Multi-objective"
      formula: "L_econ = α₁L₁ + α₂L₂ + ..."
      description: "Can combine multiple economic objectives"

# Key properties and characteristics
properties:
  - name: "Economic Focus"
    description: "Optimizes economic objectives rather than tracking performance"
    importance: "fundamental"
  - name: "Market Integration"
    description: "Incorporates market prices, demand forecasts, and economic conditions"
    importance: "fundamental"
  - name: "Multi-objective Optimization"
    description: "Can handle multiple conflicting economic objectives"
    importance: "implementation"
  - name: "Stability Considerations"
    description: "Must ensure system stability while optimizing economics"
    importance: "theoretical"
  - name: "Constraint Handling"
    description: "Maintains operational and safety constraints"
    importance: "fundamental"

# Implementation approaches with detailed code
implementations:
  - type: "basic_economic_mpc"
    name: "Basic Economic MPC Controller"
    description: "Standard Economic MPC implementation with economic stage cost"
    complexity:
      time: "O(N³)"
      space: "O(N²)"
    code: |
      import numpy as np
      from scipy.optimize import minimize
      from typing import Optional, Tuple, Callable, Dict

      class EconomicMPCController:
          """
          Economic MPC Controller implementation.

          Args:
              prediction_horizon: Number of prediction steps
              control_horizon: Number of control steps
              state_dim: Dimension of state vector
              input_dim: Dimension of input vector
              output_dim: Dimension of output vector
              economic_cost_function: Economic stage cost function
              stability_weight: Weight for stability term (optional)
          """

          def __init__(self, prediction_horizon: int, control_horizon: int,
                       state_dim: int, input_dim: int, output_dim: int,
                       economic_cost_function: Callable = None,
                       stability_weight: float = 0.1):

              self.Np = prediction_horizon
              self.Nc = min(control_horizon, prediction_horizon)
              self.nx = state_dim
              self.nu = input_dim
              self.ny = output_dim
              self.stability_weight = stability_weight

              # System functions (to be set by user)
              self.f = None  # State dynamics function
              self.h = None  # Output function
              self.g = None  # Inequality constraints
              self.economic_cost = economic_cost_function

              # Economic parameters (to be updated with market conditions)
              self.product_prices = np.ones(output_dim)
              self.input_costs = np.ones(input_dim)
              self.inventory_costs = np.ones(state_dim)
              self.energy_costs = np.ones(input_dim)

          def set_system_functions(self, f: Callable, h: Callable,
                                 g: Optional[Callable] = None) -> None:
              """
              Set system functions.

              Args:
                  f: State dynamics function f(x, u, d) -> x_next
                  h: Output function h(x, u) -> y
                  g: Inequality constraints g(x, u) -> g_val
              """
              self.f = f
              self.h = h
              self.g = g

          def update_economic_parameters(self, product_prices: np.ndarray = None,
                                       input_costs: np.ndarray = None,
                                       inventory_costs: np.ndarray = None,
                                       energy_costs: np.ndarray = None) -> None:
              """
              Update economic parameters with current market conditions.

              Args:
                  product_prices: Current product prices
                  input_costs: Current input costs
                  inventory_costs: Current inventory holding costs
                  energy_costs: Current energy costs
              """
              if product_prices is not None:
                  self.product_prices = product_prices
              if input_costs is not None:
                  self.input_costs = input_costs
              if inventory_costs is not None:
                  self.inventory_costs = inventory_costs
              if energy_costs is not None:
                  self.energy_costs = energy_costs

          def _economic_stage_cost(self, x: np.ndarray, u: np.ndarray, y: np.ndarray) -> float:
              """
              Compute economic stage cost.

              Args:
                  x: Current state
                  u: Current input
                  y: Current output

              Returns:
                  Economic stage cost
              """
              if self.economic_cost is not None:
                  return self.economic_cost(x, u, y)
              
              # Default economic cost: profit maximization
              revenue = np.dot(self.product_prices, y)
              input_cost = np.dot(self.input_costs, u)
              inventory_cost = np.dot(self.inventory_costs, x)
              energy_cost = np.dot(self.energy_costs, u)
              
              # Negative for minimization (maximize profit)
              return -(revenue - input_cost - inventory_cost - energy_cost)

          def _stability_term(self, x: np.ndarray, u: np.ndarray) -> float:
              """
              Add stability term to ensure system stability.

              Args:
                  x: Current state
                  u: Current input

              Returns:
                  Stability penalty term
              """
              # Simple stability term: penalize large states and inputs
              return self.stability_weight * (np.dot(x, x) + np.dot(u, u))

          def _predict_trajectory(self, x0: np.ndarray, U: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
              """
              Predict state and output trajectories.

              Args:
                  x0: Initial state
                  U: Control sequence

              Returns:
                  Tuple of (state_trajectory, output_trajectory)
              """
              X = np.zeros((self.Np, self.nx))
              Y = np.zeros((self.Np, self.ny))
              
              x = x0.copy()
              for i in range(self.Np):
                  if i < self.Nc:
                      u = U[i]
                  else:
                      u = U[-1]  # Hold last control action
                  
                  # Predict next state
                  x = self.f(x, u, np.zeros(self.nx))  # Assume no disturbance
                  X[i] = x
                  
                  # Predict output
                  Y[i] = self.h(x, u)
              
              return X, Y

          def _economic_objective(self, U_flat: np.ndarray, x0: np.ndarray) -> float:
              """
              Economic objective function.

              Args:
                  U_flat: Flattened control sequence
                  x0: Initial state

              Returns:
                  Total economic cost
              """
              U = U_flat.reshape(self.Nc, self.nu)
              X, Y = self._predict_trajectory(x0, U)
              
              total_cost = 0.0
              
              for i in range(self.Np):
                  if i < self.Nc:
                      u = U[i]
                  else:
                      u = U[-1]
                  
                  # Economic stage cost
                  economic_cost = self._economic_stage_cost(X[i], u, Y[i])
                  total_cost += economic_cost
                  
                  # Stability term
                  stability_cost = self._stability_term(X[i], u)
                  total_cost += stability_cost
              
              return total_cost

          def _constraints(self, U_flat: np.ndarray, x0: np.ndarray) -> List[dict]:
              """
              Constraint functions for optimization.

              Args:
                  U_flat: Flattened control sequence
                  x0: Initial state

              Returns:
                  List of constraint dictionaries
              """
              U = U_flat.reshape(self.Nc, self.nu)
              X, Y = self._predict_trajectory(x0, U)
              
              constraints = []
              
              # Inequality constraints
              if self.g is not None:
                  for i in range(self.Np):
                      if i < self.Nc:
                          u = U[i]
                      else:
                          u = U[-1]
                      
                      g_val = self.g(X[i], u)
                      if g_val.size > 0:
                          constraints.append({
                              'type': 'ineq',
                              'fun': lambda x, i=i, u=u: -self.g(X[i], u)
                          })
              
              return constraints

          def solve_economic_mpc(self, x0: np.ndarray,
                                u_min: Optional[np.ndarray] = None,
                                u_max: Optional[np.ndarray] = None) -> np.ndarray:
              """
              Solve Economic MPC optimization problem.

              Args:
                  x0: Current state
                  u_min: Input lower bounds
                  u_max: Input upper bounds

              Returns:
                  Optimal control sequence
              """
              if self.f is None or self.h is None:
                  raise ValueError("System functions must be set before solving")

              # Initial guess
              U0 = np.zeros(self.Nc * self.nu)
              
              # Bounds
              bounds = []
              if u_min is not None and u_max is not None:
                  for i in range(self.Nc):
                      bounds.extend([(u_min[j], u_max[j]) for j in range(self.nu)])

              # Constraints
              constraints = self._constraints(U0, x0)

              # Solve economic optimization problem
              result = minimize(
                  fun=lambda u: self._economic_objective(u, x0),
                  x0=U0,
                  method='SLSQP',
                  bounds=bounds,
                  constraints=constraints,
                  options={'maxiter': 1000}
              )

              return result.x.reshape(self.Nc, self.nu)

          def control_step(self, x: np.ndarray,
                          u_min: Optional[np.ndarray] = None,
                          u_max: Optional[np.ndarray] = None) -> np.ndarray:
              """
              Perform one Economic MPC control step.

              Args:
                  x: Current state
                  u_min: Input lower bounds
                  u_max: Input upper bounds

              Returns:
                  Control action to apply
              """
              # Solve economic MPC problem
              U_opt = self.solve_economic_mpc(x, u_min, u_max)
              
              # Return first control action
              return U_opt[0]
    advantages:
      - "Direct optimization of economic objectives"
      - "Incorporates market conditions and forecasts"
      - "Handles multiple economic objectives"
      - "Maintains operational constraints"
    disadvantages:
      - "May not guarantee stability without additional terms"
      - "Requires accurate economic models"
      - "Complex tuning of economic parameters"
      - "May be sensitive to market fluctuations"

# Comprehensive complexity analysis
complexity:
  analysis:
    - approach: "Basic Economic MPC"
      time: "O(N³)"
      space: "O(N²)"
      notes: "Complexity depends on prediction horizon N and system dimensions"
    - approach: "Multi-objective Economic MPC"
      time: "O(N⁴)"
      space: "O(N³)"
      notes: "Higher complexity for multiple economic objectives"

  performance_notes:
    - "Economic optimization requires real-time solution"
    - "Computational complexity scales with prediction horizon"
    - "Memory requirements scale with system dimensions"

# Applications and use cases
applications:
  - category: "Process Industries"
    examples:
      - "Chemical Plants: Profit maximization in reactor control"
      - "Oil Refineries: Energy optimization in distillation columns"
      - "Power Plants: Economic dispatch and load following"
      - "Manufacturing: Production optimization with market demand"

  - category: "Energy Systems"
    examples:
      - "Smart Grids: Economic optimization of power generation and distribution"
      - "Renewable Energy: Profit maximization with market prices"
      - "Battery Management: Economic optimization of charging and discharging"
      - "Microgrids: Economic operation of distributed energy resources"

  - category: "Automotive Systems"
    examples:
      - "Hybrid Vehicles: Fuel economy optimization"
      - "Electric Vehicles: Energy cost minimization"
      - "Fleet Management: Route optimization for cost reduction"
      - "Autonomous Vehicles: Energy-efficient path planning"

  - category: "Supply Chain Management"
    examples:
      - "Inventory Control: Cost minimization with demand forecasting"
      - "Production Planning: Profit maximization with capacity constraints"
      - "Logistics: Transportation cost optimization"
      - "Resource Allocation: Optimal resource utilization"

  - category: "Financial Systems"
    examples:
      - "Portfolio Management: Risk-adjusted return optimization"
      - "Trading Systems: Profit maximization with risk constraints"
      - "Insurance: Premium optimization with risk assessment"
      - "Banking: Loan portfolio optimization"

# Educational value and learning objectives
educational_value:
  - "Control Theory: Economic optimization in control systems"
  - "Optimization: Multi-objective optimization and economic modeling"
  - "System Analysis: Economic performance metrics and trade-offs"
  - "Real-time Systems: Implementation of economic optimization algorithms"

# Implementation status and development info
status:
  current: "planned"
  implementation_quality: "none"
  test_coverage: "none"
  documentation_quality: "planned"

  # Source code locations
  source_files:
    - path: "src/algokit/mpc/economic_mpc.py"
      description: "Main implementation with economic optimization"
    - path: "tests/unit/mpc/test_economic_mpc.py"
      description: "Comprehensive test suite including economic performance tests"

# References and resources - structured format for template rendering
references:
  - category: "Core Textbooks"
    items:
      - author: "Rawlings, J. B., Mayne, D. Q., & Diehl, M."
        year: "2017"
        title: "Model Predictive Control: Theory, Computation, and Design"
        publisher: "Nob Hill Publishing"
        note: "ISBN 978-0-9759377-0-9"
      - author: "Cannon, M., & Kouvaritakis, B."
        year: "2017"
        title: "Model Predictive Control: Classical, Robust and Stochastic"
        publisher: "Springer"
        note: "ISBN 978-3-319-42053-9"

  - category: "Economic MPC Theory"
    items:
      - author: "Rawlings, J. B., & Amrit, R."
        year: "2009"
        title: "Optimizing process economic performance using model predictive control"
        publisher: "Nonlinear Model Predictive Control"
        note: "Pages 119-138"
      - author: "Ellis, M., & Christofides, P. D."
        year: "2014"
        title: "Economic model predictive control with time-varying objective function for nonlinear process systems"
        publisher: "AIChE Journal"
        note: "Volume 60, pages 507-519"

  - category: "Online Resources"
    items:
      - title: "Economic MPC"
        url: "https://en.wikipedia.org/wiki/Model_predictive_control"
        note: "Wikipedia article on MPC"
      - title: "Process Optimization"
        url: "https://www.controleng.com/articles/economic-model-predictive-control/"
        note: "Control Engineering article on economic MPC"
      - title: "Market-based Control"
        url: "https://www.mathworks.com/help/mpc/economic-model-predictive-control.html"
        note: "MATLAB Economic MPC documentation"

  - category: "Implementation & Practice"
    items:
      - title: "GAMS"
        url: "https://www.gams.com/"
        note: "General Algebraic Modeling System for optimization"
      - title: "Pyomo"
        url: "https://pyomo.readthedocs.io/"
        note: "Python-based optimization modeling language"
      - title: "CVXPY"
        url: "https://www.cvxpy.org/"
        note: "Python-embedded modeling language for convex optimization"

# Tags for categorization and search
tags:
  - "mpc"
  - "economic-mpc"
  - "economic-optimization"
  - "profit-maximization"
  - "process-optimization"
  - "algorithms"

# Related algorithms and cross-references
related_algorithms:
  - slug: "model-predictive-control"
    relationship: "specialization"
    description: "Economic MPC is a specialized form of MPC for economic optimization"
  - slug: "linear-mpc"
    relationship: "extension"
    description: "Economic MPC can be applied to linear systems with economic objectives"
  - slug: "nonlinear-mpc"
    relationship: "extension"
    description: "Economic MPC can be applied to nonlinear systems with economic objectives"
