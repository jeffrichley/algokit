# Enhanced Algorithm Schema for Algorithm Documentation
# This schema supports all algorithm types with rich metadata and structured content

# Basic metadata
slug: matrix_chain_multiplication
name: Matrix Chain Multiplication
family_id: dp
aliases: ["Matrix Chain Ordering", "Optimal Parenthesization"]
order: 5

# Brief one-sentence summary for cards and navigation
summary: "Find optimal parenthesization for matrix chain multiplication to minimize operations using dynamic programming."

# Detailed description (markdown supported) - full overview for the algorithm page
description: |
  Matrix Chain Multiplication is a classic dynamic programming problem that finds the optimal
  way to parenthesize a sequence of matrices to minimize the number of scalar multiplications.

  Given a sequence of matrices A₁, A₂, ..., Aₙ with dimensions p₀×p₁, p₁×p₂, ..., pₙ₋₁×pₙ,
  find the optimal parenthesization that minimizes the total number of scalar multiplications.

  This problem has applications in computer graphics, scientific computing, and optimization
  of linear algebra operations.

# Problem formulation
formulation:
  problem_definition: |
    Given matrices A₁, A₂, ..., Aₙ with dimensions p₀×p₁, p₁×p₂, ..., pₙ₋₁×pₙ,
    find the optimal parenthesization to minimize scalar multiplications.
  recurrence_relation: |
    M[i,j] = {
      0,                                    if i = j
      min(M[i,k] + M[k+1,j] + p[i-1]×p[k]×p[j]),  for k in [i, j-1]
    }

# Key properties
properties:
  - name: "Optimal Substructure"
    description: "Optimal solution contains optimal solutions to subproblems"
    importance: "fundamental"
  - name: "Overlapping Subproblems"
    description: "Same subproblems solved multiple times in recursive approach"
    importance: "fundamental"
  - name: "Interval DP"
    description: "Works on intervals of the sequence"
    importance: "structural"
  - name: "Associative Property"
    description: "Matrix multiplication is associative but not commutative"
    importance: "mathematical"

# Mathematical properties
mathematical_properties:
  - name: "Time Complexity"
    formula: "O(n³)"
    description: "Where n is the number of matrices"
  - name: "Space Complexity"
    formula: "O(n²)"
    description: "For DP table and split tracking"
  - name: "Naive Complexity"
    formula: "O(4ⁿ/√(πn³))"
    description: "Catalan number of possible parenthesizations"
  - name: "Cost Formula"
    formula: "p[i-1] × p[k] × p[j]"
    description: "Cost of multiplying matrices from i to j with split at k"

# Implementation approaches
implementations:
  - name: "Recursive (Naive)"
    description: "Direct recursive implementation trying all possible parenthesizations"
    complexity:
      time: "O(4ⁿ/√(πn³))"
      space: "O(n)"
    advantages:
      - "Simple to understand"
      - "Direct implementation of problem definition"
    disadvantages:
      - "Exponential time complexity"
      - "Redundant computation of same subproblems"
    use_cases: ["Educational purposes", "Very small input sizes"]

  - name: "Memoized (Top-Down)"
    description: "Recursive approach with memoization to avoid redundant calculations"
    complexity:
      time: "O(n³)"
      space: "O(n²)"
    advantages:
      - "Natural recursive structure"
      - "Only computes needed subproblems"
      - "Easy to understand"
    disadvantages:
      - "Recursion stack overhead"
      - "May cause stack overflow for large inputs"
    use_cases: ["Medium-sized inputs", "When recursive approach is preferred"]

  - name: "Tabulated (Bottom-Up)"
    description: "Iterative approach building solution from base cases"
    complexity:
      time: "O(n³)"
      space: "O(n²)"
    advantages:
      - "No recursion stack issues"
      - "More predictable memory usage"
      - "Better for large inputs"
    disadvantages:
      - "Computes all subproblems"
      - "Less intuitive than recursive approach"
    use_cases: ["Large inputs", "Production systems", "Memory-constrained environments"]

  - name: "Value Only"
    description: "Computes only the minimum cost without tracking optimal parenthesization"
    complexity:
      time: "O(n³)"
      space: "O(n²)"
    advantages:
      - "Simpler implementation"
      - "Lower constant factors"
    disadvantages:
      - "Cannot reconstruct optimal parenthesization"
      - "Limited usefulness"
    use_cases: ["When only cost is needed", "Performance-critical applications"]

  - name: "With Expression"
    description: "Tracks and returns the optimal parenthesization expression"
    complexity:
      time: "O(n³)"
      space: "O(n²)"
    advantages:
      - "Provides actual optimal parenthesization"
      - "Useful for implementation guidance"
    disadvantages:
      - "Higher memory usage"
      - "More complex implementation"
    use_cases: ["When parenthesization is needed", "Code generation tools"]

# Complexity analysis
complexity:
  time:
    best: "O(n³)"
    average: "O(n³)"
    worst: "O(n³)"
    notes: "Time complexity is consistent across all cases"
  space:
    best: "O(n²)"
    average: "O(n²)"
    worst: "O(n²)"
    notes: "Space complexity is O(n²) for DP table and split tracking"

# Applications and use cases
applications:
  - category: "Computer Graphics"
    examples: ["3D transformations", "Matrix operations", "Rendering pipelines"]
  - category: "Scientific Computing"
    examples: ["Linear algebra operations", "Numerical analysis", "Simulation"]
  - category: "Machine Learning"
    examples: ["Neural network operations", "Matrix computations", "Optimization"]
  - category: "Compiler Optimization"
    examples: ["Expression optimization", "Code generation", "Performance tuning"]
  - category: "Parallel Computing"
    examples: ["Load balancing", "Task scheduling", "Resource allocation"]

# Educational value
educational_value:
  - "Understand dynamic programming principles"
  - "Learn interval DP techniques"
  - "Practice with 2D DP problems"
  - "Understand optimization problems"
  - "Learn matrix operations"
  - "Matrix multiplication concepts"

# Implementation status and development info
status:
  current: "complete"
  implementation_quality: "high"
  test_coverage: "high"
  documentation_quality: "complete"

  # Source code locations
  source_files:
    - path: "src/algokit/algorithms/dynamic_programming/matrix_chain_multiplication.py"
      description: "Main implementation file"
    - path: "tests/dynamic_programming/test_matrix_chain_multiplication.py"
      description: "Test suite"

# Related algorithms and cross-references
related_algorithms:
  - slug: "fibonacci"
    relationship: "prerequisite"
    description: "Simpler DP problem to understand first"
  - slug: "knapsack"
    relationship: "similar"
    description: "Both are optimization DP problems"
  - slug: "longest_common_subsequence"
    relationship: "similar"
    description: "Both use 2D DP techniques"

# References and resources
references:
  - category: "Core Textbooks"
    items:
      - bib_key: "cormen2009"
      - bib_key: "clrs_matrix_chain"
  - category: "Online Resources"
    items:
      - bib_key: "geeksforgeeks_matrix_chain"

# Tags for categorization and search
tags:
  - "dp"
  - "optimization"
  - "matrix"
  - "interval-dp"
  - "2d-dp"

# Template and rendering options
template_options:
  show_complexity_analysis: true
  show_implementations: true
  show_applications: true
  show_educational_value: true
  show_related_algorithms: true
  show_references: true
